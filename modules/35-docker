#!/usr/bin/env bash

set -euo pipefail
# shellcheck source=./framework.sh
source "${BASE_DIR}/framework.sh"

type docker > /dev/null 2>&1 || exit 1

# Get docker container name, status, uptime and compose stack
containers=$(docker ps -a --format "{{ .Label \"com.docker.compose.project\" }},{{ .Names }},{{ .Status }},{{ .State }}")

text=""
if [[ -z "${containers}" ]]; then
    text+="no containers\n"
else
    declare -A stacks
    declare -A stack_state

    while IFS= read -r line; do
        IFS=$',' read -r stack name description state <<< "${line}"

        # Choose color based on state
        case ${state} in
            running) color="${CO}" ;;
            paused | restarting) color="${CW}" ;;
            exited | dead) color="${CE}" ;;
            *) color="${CN}" ;;
        esac

        if [[ -n "${stack}" ]]; then
            # Track the "worst" state for the stack
            if [[ "${state}" != "running" ]]; then
                stacks["$stack"]=1
                stack_state["$stack"]="${color}${description,,}${CN}"
            elif [[ -z "${stacks["$stack"]+x}" ]]; then
                stacks["$stack"]=0
                stack_state["$stack"]="${CO}running${CN}"
            fi
        else
            # Single container (not part of a stack) → always display
            text+="$(print_split "${WIDTH}" "${name}" "${color}${description,,}${CN}")\n"
        fi
    done <<< "${containers}"

    # Print stack summary
    for stack in "${!stacks[@]}"; do
        if [[ ${stacks[$stack]} -eq 1 ]]; then
            # At least one container not healthy → show warning
            text+="$(print_split "${WIDTH}" "${stack}" "${stack_state[$stack]}")\n"
        else
            # Everything fine → just show running
            text+="$(print_split "${WIDTH}" "${stack}" "${stack_state[$stack]}")\n"
        fi
    done
fi

print_columns "Docker" "${text::-2}"
