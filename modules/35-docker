#!/usr/bin/env bash

set -euo pipefail
# shellcheck source=./framework.sh
source "${BASE_DIR}/framework.sh"

type docker > /dev/null 2>&1 || exit 1

# Get docker container name, status, uptime and compose stack
containers=$(docker ps -a --format "{{ .Label \"com.docker.compose.project\" }},{{ .Names }},{{ .Status }},{{ .State }}")

stacks_text=""
containers_text=""

if [[ -z "${containers}" ]]; then
    stacks_text+="no containers\n"
else
    declare -A stacks
    declare -A stack_state

    while IFS= read -r line; do
        IFS=$',' read -r stack name description state <<< "${line}"

        # Choose color based on state
        case ${state} in
            running) color="${CO}" ;;
            paused | restarting) color="${CW}" ;;
            exited | dead) color="${CE}" ;;
            *) color="${CN}" ;;
        esac

        if [[ -n "${stack}" ]]; then
            # Track the "worst" state for the stack
            if [[ "${state}" != "running" ]]; then
                stacks["$stack"]=1
                stack_state["$stack"]="${color}${description,,}${CN}"
            elif [[ -z "${stacks["$stack"]+x}" ]]; then
                stacks["$stack"]=0
                stack_state["$stack"]="${CO}running${CN}"
            fi
        else
            # Single container (not part of a stack) â†’ always display
            containers_text+="$(print_split "${WIDTH}" "${name}" "${color}${description,,}${CN}")\n"
        fi
    done <<< "${containers}"

    # Print stack summary
    for stack in "${!stacks[@]}"; do
        stacks_text+="$(print_split "${WIDTH}" "${stack}" "${stack_state[$stack]}")\n"
    done
fi

# Print sections
if [[ -n "${stacks_text}" ]]; then
    print_columns "Compose-Stacks" "${stacks_text::-2}"
fi

if [[ -n "${containers_text}" ]]; then
    print_columns "Containers" "${containers_text::-2}"
fi
